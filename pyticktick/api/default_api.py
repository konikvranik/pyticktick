# coding: utf-8

"""
TickTick API

[TickTick](https://ticktick.com/) TODO task manager.

The version of the OpenAPI document: 0.0.1
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""  # noqa: E501

import re  # noqa: F401

from pydantic import validate_arguments
from typing import Optional

from typing_extensions import Annotated
from pydantic import Field, StrictStr

from typing import List

from pyticktick.models.oauth_token_post200_response import OauthTokenPost200Response
from pyticktick.models.oauth_token_post_request import OauthTokenPostRequest
from pyticktick.models.open_v1_project_project_id_post_request import OpenV1ProjectProjectIdPostRequest
from pyticktick.models.open_v1_project_project_id_task_task_id_complete_post_request import (
	OpenV1ProjectProjectIdTaskTaskIdCompletePostRequest,
)
from pyticktick.models.open_v1_task_task_id_post_request import OpenV1TaskTaskIdPostRequest
from pyticktick.models.project import Project
from pyticktick.models.project_data import ProjectData
from pyticktick.models.task import Task

from pyticktick.api_client import ApiClient
from pyticktick.api_response import ApiResponse
from pyticktick.exceptions import (  # noqa: F401
	ApiTypeError,
	ApiValueError,
)


class DefaultApi:
	"""NOTE: This class is auto generated by OpenAPI Generator
	Ref: https://openapi-generator.tech

	Do not edit the class manually.
	"""

	def __init__(self, api_client=None) -> None:
		if api_client is None:
			api_client = ApiClient.get_default()
		self.api_client = api_client

	@validate_arguments
	async def oauth_token_post(
		self, oauth_token_post_request: Optional[OauthTokenPostRequest] = None, **kwargs
	) -> OauthTokenPost200Response:  # noqa: E501
		"""Get token  # noqa: E501

		client_id and :client_secret are passes to basic auth as username and password  # noqa: E501

		:param oauth_token_post_request:
		:type oauth_token_post_request: OauthTokenPostRequest
		:param _request_timeout: timeout setting for this request.
		       If one number provided, it will be total request
		       timeout. It can also be a pair (tuple) of
		       (connection, read) timeouts.
		:return: Returns the result object.
		         If the method is called asynchronously,
		         returns the request thread.
		:rtype: OauthTokenPost200Response
		"""
		kwargs["_return_http_data_only"] = True
		if "_preload_content" in kwargs:
			message = "Error! Please call the oauth_token_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
			raise ValueError(message)
		return await self.oauth_token_post_with_http_info(oauth_token_post_request, **kwargs)  # noqa: E501

	@validate_arguments
	async def oauth_token_post_with_http_info(
		self, oauth_token_post_request: Optional[OauthTokenPostRequest] = None, **kwargs
	) -> ApiResponse:  # noqa: E501
		"""Get token  # noqa: E501

		client_id and :client_secret are passes to basic auth as username and password  # noqa: E501

		:param oauth_token_post_request:
		:type oauth_token_post_request: OauthTokenPostRequest
		:param _preload_content: if False, the ApiResponse.data will
		                         be set to none and raw_data will store the
		                         HTTP response body without reading/decoding.
		                         Default is True.
		:type _preload_content: bool, optional
		:param _return_http_data_only: response data instead of ApiResponse
		                               object with status code, headers, etc
		:type _return_http_data_only: bool, optional
		:param _request_timeout: timeout setting for this request. If one
		                         number provided, it will be total request
		                         timeout. It can also be a pair (tuple) of
		                         (connection, read) timeouts.
		:param _request_auth: set to override the auth_settings for an a single
		                      request; this effectively ignores the authentication
		                      in the spec for a single request.
		:type _request_auth: dict, optional
		:type _content_type: string, optional: force content-type for the request
		:return: Returns the result object.
		         If the method is called asynchronously,
		         returns the request thread.
		:rtype: tuple(OauthTokenPost200Response, status_code(int), headers(HTTPHeaderDict))
		"""

		_params = locals()

		_all_params = ["oauth_token_post_request"]
		_all_params.extend(
			[
				"_return_http_data_only",
				"_preload_content",
				"_request_timeout",
				"_request_auth",
				"_content_type",
				"_headers",
			]
		)

		# validate the arguments
		for _key, _val in _params["kwargs"].items():
			if _key not in _all_params:
				raise ApiTypeError("Got an unexpected keyword argument '%s' to method oauth_token_post" % _key)
			_params[_key] = _val
		del _params["kwargs"]

		_collection_formats = {}

		# process the path parameters
		_path_params = {}

		# process the query parameters
		_query_params = []
		# process the header parameters
		_header_params = dict(_params.get("_headers", {}))
		# process the form parameters
		_form_params = []
		_files = {}
		# process the body parameter
		_body_params = None
		if _params["oauth_token_post_request"] is not None:
			_body_params = _params["oauth_token_post_request"]

		# set the HTTP header `Accept`
		_header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501

		# set the HTTP header `Content-Type`
		_content_types_list = _params.get(
			"_content_type", self.api_client.select_header_content_type(["application/json"])
		)
		if _content_types_list:
			_header_params["Content-Type"] = _content_types_list

		# authentication setting
		_auth_settings = ["BasicAuth"]  # noqa: E501

		_response_types_map = {
			"200": "OauthTokenPost200Response",
		}

		return await self.api_client.call_api(
			"/oauth/token",
			"POST",
			_path_params,
			_query_params,
			_header_params,
			body=_body_params,
			post_params=_form_params,
			files=_files,
			response_types_map=_response_types_map,
			auth_settings=_auth_settings,
			_return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
			_preload_content=_params.get("_preload_content", True),
			_request_timeout=_params.get("_request_timeout"),
			collection_formats=_collection_formats,
			_request_auth=_params.get("_request_auth"),
		)

	@validate_arguments
	async def open_v1_project_get(self, **kwargs) -> List[Project]:  # noqa: E501
		"""Get User Project.  # noqa: E501


		:param _request_timeout: timeout setting for this request.
		       If one number provided, it will be total request
		       timeout. It can also be a pair (tuple) of
		       (connection, read) timeouts.
		:return: Returns the result object.
		         If the method is called asynchronously,
		         returns the request thread.
		:rtype: List[Project]
		"""
		kwargs["_return_http_data_only"] = True
		if "_preload_content" in kwargs:
			message = "Error! Please call the open_v1_project_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
			raise ValueError(message)
		return await self.open_v1_project_get_with_http_info(**kwargs)  # noqa: E501

	@validate_arguments
	async def open_v1_project_get_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
		"""Get User Project.  # noqa: E501


		:param _preload_content: if False, the ApiResponse.data will
		                         be set to none and raw_data will store the
		                         HTTP response body without reading/decoding.
		                         Default is True.
		:type _preload_content: bool, optional
		:param _return_http_data_only: response data instead of ApiResponse
		                               object with status code, headers, etc
		:type _return_http_data_only: bool, optional
		:param _request_timeout: timeout setting for this request. If one
		                         number provided, it will be total request
		                         timeout. It can also be a pair (tuple) of
		                         (connection, read) timeouts.
		:param _request_auth: set to override the auth_settings for an a single
		                      request; this effectively ignores the authentication
		                      in the spec for a single request.
		:type _request_auth: dict, optional
		:type _content_type: string, optional: force content-type for the request
		:return: Returns the result object.
		         If the method is called asynchronously,
		         returns the request thread.
		:rtype: tuple(List[Project], status_code(int), headers(HTTPHeaderDict))
		"""

		_params = locals()

		_all_params = []
		_all_params.extend(
			[
				"_return_http_data_only",
				"_preload_content",
				"_request_timeout",
				"_request_auth",
				"_content_type",
				"_headers",
			]
		)

		# validate the arguments
		for _key, _val in _params["kwargs"].items():
			if _key not in _all_params:
				raise ApiTypeError("Got an unexpected keyword argument '%s' to method open_v1_project_get" % _key)
			_params[_key] = _val
		del _params["kwargs"]

		_collection_formats = {}

		# process the path parameters
		_path_params = {}

		# process the query parameters
		_query_params = []
		# process the header parameters
		_header_params = dict(_params.get("_headers", {}))
		# process the form parameters
		_form_params = []
		_files = {}
		# process the body parameter
		_body_params = None
		# set the HTTP header `Accept`
		_header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501

		# authentication setting
		_auth_settings = ["OAuth2", "BearerAuth"]  # noqa: E501

		_response_types_map = {
			"200": "List[Project]",
			"401": None,
			"403": None,
			"404": None,
		}

		return await self.api_client.call_api(
			"/open/v1/project",
			"GET",
			_path_params,
			_query_params,
			_header_params,
			body=_body_params,
			post_params=_form_params,
			files=_files,
			response_types_map=_response_types_map,
			auth_settings=_auth_settings,
			_return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
			_preload_content=_params.get("_preload_content", True),
			_request_timeout=_params.get("_request_timeout"),
			collection_formats=_collection_formats,
			_request_auth=_params.get("_request_auth"),
		)

	@validate_arguments
	async def open_v1_project_post(self, project: Project, **kwargs) -> Project:  # noqa: E501
		"""Create Project  # noqa: E501


		:param project: (required)
		:type project: Project
		:param _request_timeout: timeout setting for this request.
		       If one number provided, it will be total request
		       timeout. It can also be a pair (tuple) of
		       (connection, read) timeouts.
		:return: Returns the result object.
		         If the method is called asynchronously,
		         returns the request thread.
		:rtype: Project
		"""
		kwargs["_return_http_data_only"] = True
		if "_preload_content" in kwargs:
			message = "Error! Please call the open_v1_project_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
			raise ValueError(message)
		return await self.open_v1_project_post_with_http_info(project, **kwargs)  # noqa: E501

	@validate_arguments
	async def open_v1_project_post_with_http_info(self, project: Project, **kwargs) -> ApiResponse:  # noqa: E501
		"""Create Project  # noqa: E501


		:param project: (required)
		:type project: Project
		:param _preload_content: if False, the ApiResponse.data will
		                         be set to none and raw_data will store the
		                         HTTP response body without reading/decoding.
		                         Default is True.
		:type _preload_content: bool, optional
		:param _return_http_data_only: response data instead of ApiResponse
		                               object with status code, headers, etc
		:type _return_http_data_only: bool, optional
		:param _request_timeout: timeout setting for this request. If one
		                         number provided, it will be total request
		                         timeout. It can also be a pair (tuple) of
		                         (connection, read) timeouts.
		:param _request_auth: set to override the auth_settings for an a single
		                      request; this effectively ignores the authentication
		                      in the spec for a single request.
		:type _request_auth: dict, optional
		:type _content_type: string, optional: force content-type for the request
		:return: Returns the result object.
		         If the method is called asynchronously,
		         returns the request thread.
		:rtype: tuple(Project, status_code(int), headers(HTTPHeaderDict))
		"""

		_params = locals()

		_all_params = ["project"]
		_all_params.extend(
			[
				"_return_http_data_only",
				"_preload_content",
				"_request_timeout",
				"_request_auth",
				"_content_type",
				"_headers",
			]
		)

		# validate the arguments
		for _key, _val in _params["kwargs"].items():
			if _key not in _all_params:
				raise ApiTypeError("Got an unexpected keyword argument '%s' to method open_v1_project_post" % _key)
			_params[_key] = _val
		del _params["kwargs"]

		_collection_formats = {}

		# process the path parameters
		_path_params = {}

		# process the query parameters
		_query_params = []
		# process the header parameters
		_header_params = dict(_params.get("_headers", {}))
		# process the form parameters
		_form_params = []
		_files = {}
		# process the body parameter
		_body_params = None
		if _params["project"] is not None:
			_body_params = _params["project"]

		# set the HTTP header `Accept`
		_header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501

		# set the HTTP header `Content-Type`
		_content_types_list = _params.get(
			"_content_type", self.api_client.select_header_content_type(["application/json"])
		)
		if _content_types_list:
			_header_params["Content-Type"] = _content_types_list

		# authentication setting
		_auth_settings = ["OAuth2", "BearerAuth"]  # noqa: E501

		_response_types_map = {
			"200": "Project",
			"201": None,
			"401": None,
			"403": None,
			"404": None,
		}

		return await self.api_client.call_api(
			"/open/v1/project",
			"POST",
			_path_params,
			_query_params,
			_header_params,
			body=_body_params,
			post_params=_form_params,
			files=_files,
			response_types_map=_response_types_map,
			auth_settings=_auth_settings,
			_return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
			_preload_content=_params.get("_preload_content", True),
			_request_timeout=_params.get("_request_timeout"),
			collection_formats=_collection_formats,
			_request_auth=_params.get("_request_auth"),
		)

	@validate_arguments
	async def open_v1_project_project_id_data_get(
		self, project_id: Annotated[StrictStr, Field(..., description="Project identifier")], **kwargs
	) -> ProjectData:  # noqa: E501
		"""open_v1_project_project_id_data_get  # noqa: E501


		:param project_id: Project identifier (required)
		:type project_id: str
		:param _request_timeout: timeout setting for this request.
		       If one number provided, it will be total request
		       timeout. It can also be a pair (tuple) of
		       (connection, read) timeouts.
		:return: Returns the result object.
		         If the method is called asynchronously,
		         returns the request thread.
		:rtype: ProjectData
		"""
		kwargs["_return_http_data_only"] = True
		if "_preload_content" in kwargs:
			message = "Error! Please call the open_v1_project_project_id_data_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
			raise ValueError(message)
		return await self.open_v1_project_project_id_data_get_with_http_info(project_id, **kwargs)  # noqa: E501

	@validate_arguments
	async def open_v1_project_project_id_data_get_with_http_info(
		self, project_id: Annotated[StrictStr, Field(..., description="Project identifier")], **kwargs
	) -> ApiResponse:  # noqa: E501
		"""open_v1_project_project_id_data_get  # noqa: E501


		:param project_id: Project identifier (required)
		:type project_id: str
		:param _preload_content: if False, the ApiResponse.data will
		                         be set to none and raw_data will store the
		                         HTTP response body without reading/decoding.
		                         Default is True.
		:type _preload_content: bool, optional
		:param _return_http_data_only: response data instead of ApiResponse
		                               object with status code, headers, etc
		:type _return_http_data_only: bool, optional
		:param _request_timeout: timeout setting for this request. If one
		                         number provided, it will be total request
		                         timeout. It can also be a pair (tuple) of
		                         (connection, read) timeouts.
		:param _request_auth: set to override the auth_settings for an a single
		                      request; this effectively ignores the authentication
		                      in the spec for a single request.
		:type _request_auth: dict, optional
		:type _content_type: string, optional: force content-type for the request
		:return: Returns the result object.
		         If the method is called asynchronously,
		         returns the request thread.
		:rtype: tuple(ProjectData, status_code(int), headers(HTTPHeaderDict))
		"""

		_params = locals()

		_all_params = ["project_id"]
		_all_params.extend(
			[
				"_return_http_data_only",
				"_preload_content",
				"_request_timeout",
				"_request_auth",
				"_content_type",
				"_headers",
			]
		)

		# validate the arguments
		for _key, _val in _params["kwargs"].items():
			if _key not in _all_params:
				raise ApiTypeError(
					"Got an unexpected keyword argument '%s' to method open_v1_project_project_id_data_get" % _key
				)
			_params[_key] = _val
		del _params["kwargs"]

		_collection_formats = {}

		# process the path parameters
		_path_params = {}
		if _params["project_id"] is not None:
			_path_params["projectId"] = _params["project_id"]

		# process the query parameters
		_query_params = []
		# process the header parameters
		_header_params = dict(_params.get("_headers", {}))
		# process the form parameters
		_form_params = []
		_files = {}
		# process the body parameter
		_body_params = None
		# set the HTTP header `Accept`
		_header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501

		# authentication setting
		_auth_settings = ["OAuth2", "BearerAuth"]  # noqa: E501

		_response_types_map = {
			"200": "ProjectData",
			"401": None,
			"403": None,
			"404": None,
		}

		return await self.api_client.call_api(
			"/open/v1/project/{projectId}/data",
			"GET",
			_path_params,
			_query_params,
			_header_params,
			body=_body_params,
			post_params=_form_params,
			files=_files,
			response_types_map=_response_types_map,
			auth_settings=_auth_settings,
			_return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
			_preload_content=_params.get("_preload_content", True),
			_request_timeout=_params.get("_request_timeout"),
			collection_formats=_collection_formats,
			_request_auth=_params.get("_request_auth"),
		)

	@validate_arguments
	async def open_v1_project_project_id_delete(
		self, project_id: Annotated[StrictStr, Field(..., description="Project identifier")], **kwargs
	) -> None:  # noqa: E501
		"""open_v1_project_project_id_delete  # noqa: E501


		:param project_id: Project identifier (required)
		:type project_id: str
		:param _request_timeout: timeout setting for this request.
		       If one number provided, it will be total request
		       timeout. It can also be a pair (tuple) of
		       (connection, read) timeouts.
		:return: Returns the result object.
		         If the method is called asynchronously,
		         returns the request thread.
		:rtype: None
		"""
		kwargs["_return_http_data_only"] = True
		if "_preload_content" in kwargs:
			message = "Error! Please call the open_v1_project_project_id_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
			raise ValueError(message)
		return await self.open_v1_project_project_id_delete_with_http_info(project_id, **kwargs)  # noqa: E501

	@validate_arguments
	async def open_v1_project_project_id_delete_with_http_info(
		self, project_id: Annotated[StrictStr, Field(..., description="Project identifier")], **kwargs
	) -> ApiResponse:  # noqa: E501
		"""open_v1_project_project_id_delete  # noqa: E501


		:param project_id: Project identifier (required)
		:type project_id: str
		:param _preload_content: if False, the ApiResponse.data will
		                         be set to none and raw_data will store the
		                         HTTP response body without reading/decoding.
		                         Default is True.
		:type _preload_content: bool, optional
		:param _return_http_data_only: response data instead of ApiResponse
		                               object with status code, headers, etc
		:type _return_http_data_only: bool, optional
		:param _request_timeout: timeout setting for this request. If one
		                         number provided, it will be total request
		                         timeout. It can also be a pair (tuple) of
		                         (connection, read) timeouts.
		:param _request_auth: set to override the auth_settings for an a single
		                      request; this effectively ignores the authentication
		                      in the spec for a single request.
		:type _request_auth: dict, optional
		:type _content_type: string, optional: force content-type for the request
		:return: Returns the result object.
		         If the method is called asynchronously,
		         returns the request thread.
		:rtype: None
		"""

		_params = locals()

		_all_params = ["project_id"]
		_all_params.extend(
			[
				"_return_http_data_only",
				"_preload_content",
				"_request_timeout",
				"_request_auth",
				"_content_type",
				"_headers",
			]
		)

		# validate the arguments
		for _key, _val in _params["kwargs"].items():
			if _key not in _all_params:
				raise ApiTypeError(
					"Got an unexpected keyword argument '%s' to method open_v1_project_project_id_delete" % _key
				)
			_params[_key] = _val
		del _params["kwargs"]

		_collection_formats = {}

		# process the path parameters
		_path_params = {}
		if _params["project_id"] is not None:
			_path_params["projectId"] = _params["project_id"]

		# process the query parameters
		_query_params = []
		# process the header parameters
		_header_params = dict(_params.get("_headers", {}))
		# process the form parameters
		_form_params = []
		_files = {}
		# process the body parameter
		_body_params = None
		# authentication setting
		_auth_settings = ["OAuth2", "BearerAuth"]  # noqa: E501

		_response_types_map = {}

		return await self.api_client.call_api(
			"/open/v1/project/{projectId}",
			"DELETE",
			_path_params,
			_query_params,
			_header_params,
			body=_body_params,
			post_params=_form_params,
			files=_files,
			response_types_map=_response_types_map,
			auth_settings=_auth_settings,
			_return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
			_preload_content=_params.get("_preload_content", True),
			_request_timeout=_params.get("_request_timeout"),
			collection_formats=_collection_formats,
			_request_auth=_params.get("_request_auth"),
		)

	@validate_arguments
	async def open_v1_project_project_id_get(
		self, project_id: Annotated[StrictStr, Field(..., description="Project identifier")], **kwargs
	) -> Project:  # noqa: E501
		"""open_v1_project_project_id_get  # noqa: E501


		:param project_id: Project identifier (required)
		:type project_id: str
		:param _request_timeout: timeout setting for this request.
		       If one number provided, it will be total request
		       timeout. It can also be a pair (tuple) of
		       (connection, read) timeouts.
		:return: Returns the result object.
		         If the method is called asynchronously,
		         returns the request thread.
		:rtype: Project
		"""
		kwargs["_return_http_data_only"] = True
		if "_preload_content" in kwargs:
			message = "Error! Please call the open_v1_project_project_id_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
			raise ValueError(message)
		return await self.open_v1_project_project_id_get_with_http_info(project_id, **kwargs)  # noqa: E501

	@validate_arguments
	async def open_v1_project_project_id_get_with_http_info(
		self, project_id: Annotated[StrictStr, Field(..., description="Project identifier")], **kwargs
	) -> ApiResponse:  # noqa: E501
		"""open_v1_project_project_id_get  # noqa: E501


		:param project_id: Project identifier (required)
		:type project_id: str
		:param _preload_content: if False, the ApiResponse.data will
		                         be set to none and raw_data will store the
		                         HTTP response body without reading/decoding.
		                         Default is True.
		:type _preload_content: bool, optional
		:param _return_http_data_only: response data instead of ApiResponse
		                               object with status code, headers, etc
		:type _return_http_data_only: bool, optional
		:param _request_timeout: timeout setting for this request. If one
		                         number provided, it will be total request
		                         timeout. It can also be a pair (tuple) of
		                         (connection, read) timeouts.
		:param _request_auth: set to override the auth_settings for an a single
		                      request; this effectively ignores the authentication
		                      in the spec for a single request.
		:type _request_auth: dict, optional
		:type _content_type: string, optional: force content-type for the request
		:return: Returns the result object.
		         If the method is called asynchronously,
		         returns the request thread.
		:rtype: tuple(Project, status_code(int), headers(HTTPHeaderDict))
		"""

		_params = locals()

		_all_params = ["project_id"]
		_all_params.extend(
			[
				"_return_http_data_only",
				"_preload_content",
				"_request_timeout",
				"_request_auth",
				"_content_type",
				"_headers",
			]
		)

		# validate the arguments
		for _key, _val in _params["kwargs"].items():
			if _key not in _all_params:
				raise ApiTypeError(
					"Got an unexpected keyword argument '%s' to method open_v1_project_project_id_get" % _key
				)
			_params[_key] = _val
		del _params["kwargs"]

		_collection_formats = {}

		# process the path parameters
		_path_params = {}
		if _params["project_id"] is not None:
			_path_params["projectId"] = _params["project_id"]

		# process the query parameters
		_query_params = []
		# process the header parameters
		_header_params = dict(_params.get("_headers", {}))
		# process the form parameters
		_form_params = []
		_files = {}
		# process the body parameter
		_body_params = None
		# set the HTTP header `Accept`
		_header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501

		# authentication setting
		_auth_settings = ["OAuth2", "BearerAuth"]  # noqa: E501

		_response_types_map = {
			"200": "Project",
			"401": None,
			"403": None,
			"404": None,
		}

		return await self.api_client.call_api(
			"/open/v1/project/{projectId}",
			"GET",
			_path_params,
			_query_params,
			_header_params,
			body=_body_params,
			post_params=_form_params,
			files=_files,
			response_types_map=_response_types_map,
			auth_settings=_auth_settings,
			_return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
			_preload_content=_params.get("_preload_content", True),
			_request_timeout=_params.get("_request_timeout"),
			collection_formats=_collection_formats,
			_request_auth=_params.get("_request_auth"),
		)

	@validate_arguments
	async def open_v1_project_project_id_post(
		self,
		project_id: Annotated[StrictStr, Field(..., description="Project identifier")],
		open_v1_project_project_id_post_request: OpenV1ProjectProjectIdPostRequest,
		**kwargs,
	) -> Project:  # noqa: E501
		"""Update Project  # noqa: E501


		:param project_id: Project identifier (required)
		:type project_id: str
		:param open_v1_project_project_id_post_request: (required)
		:type open_v1_project_project_id_post_request: OpenV1ProjectProjectIdPostRequest
		:param _request_timeout: timeout setting for this request.
		       If one number provided, it will be total request
		       timeout. It can also be a pair (tuple) of
		       (connection, read) timeouts.
		:return: Returns the result object.
		         If the method is called asynchronously,
		         returns the request thread.
		:rtype: Project
		"""
		kwargs["_return_http_data_only"] = True
		if "_preload_content" in kwargs:
			message = "Error! Please call the open_v1_project_project_id_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
			raise ValueError(message)
		return await self.open_v1_project_project_id_post_with_http_info(
			project_id, open_v1_project_project_id_post_request, **kwargs
		)  # noqa: E501

	@validate_arguments
	async def open_v1_project_project_id_post_with_http_info(
		self,
		project_id: Annotated[StrictStr, Field(..., description="Project identifier")],
		open_v1_project_project_id_post_request: OpenV1ProjectProjectIdPostRequest,
		**kwargs,
	) -> ApiResponse:  # noqa: E501
		"""Update Project  # noqa: E501


		:param project_id: Project identifier (required)
		:type project_id: str
		:param open_v1_project_project_id_post_request: (required)
		:type open_v1_project_project_id_post_request: OpenV1ProjectProjectIdPostRequest
		:param _preload_content: if False, the ApiResponse.data will
		                         be set to none and raw_data will store the
		                         HTTP response body without reading/decoding.
		                         Default is True.
		:type _preload_content: bool, optional
		:param _return_http_data_only: response data instead of ApiResponse
		                               object with status code, headers, etc
		:type _return_http_data_only: bool, optional
		:param _request_timeout: timeout setting for this request. If one
		                         number provided, it will be total request
		                         timeout. It can also be a pair (tuple) of
		                         (connection, read) timeouts.
		:param _request_auth: set to override the auth_settings for an a single
		                      request; this effectively ignores the authentication
		                      in the spec for a single request.
		:type _request_auth: dict, optional
		:type _content_type: string, optional: force content-type for the request
		:return: Returns the result object.
		         If the method is called asynchronously,
		         returns the request thread.
		:rtype: tuple(Project, status_code(int), headers(HTTPHeaderDict))
		"""

		_params = locals()

		_all_params = ["project_id", "open_v1_project_project_id_post_request"]
		_all_params.extend(
			[
				"_return_http_data_only",
				"_preload_content",
				"_request_timeout",
				"_request_auth",
				"_content_type",
				"_headers",
			]
		)

		# validate the arguments
		for _key, _val in _params["kwargs"].items():
			if _key not in _all_params:
				raise ApiTypeError(
					"Got an unexpected keyword argument '%s' to method open_v1_project_project_id_post" % _key
				)
			_params[_key] = _val
		del _params["kwargs"]

		_collection_formats = {}

		# process the path parameters
		_path_params = {}
		if _params["project_id"] is not None:
			_path_params["projectId"] = _params["project_id"]

		# process the query parameters
		_query_params = []
		# process the header parameters
		_header_params = dict(_params.get("_headers", {}))
		# process the form parameters
		_form_params = []
		_files = {}
		# process the body parameter
		_body_params = None
		if _params["open_v1_project_project_id_post_request"] is not None:
			_body_params = _params["open_v1_project_project_id_post_request"]

		# set the HTTP header `Accept`
		_header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501

		# set the HTTP header `Content-Type`
		_content_types_list = _params.get(
			"_content_type", self.api_client.select_header_content_type(["application/json"])
		)
		if _content_types_list:
			_header_params["Content-Type"] = _content_types_list

		# authentication setting
		_auth_settings = ["OAuth2", "BearerAuth"]  # noqa: E501

		_response_types_map = {
			"200": "Project",
			"201": None,
			"401": None,
			"403": None,
			"404": None,
		}

		return await self.api_client.call_api(
			"/open/v1/project/{projectId}",
			"POST",
			_path_params,
			_query_params,
			_header_params,
			body=_body_params,
			post_params=_form_params,
			files=_files,
			response_types_map=_response_types_map,
			auth_settings=_auth_settings,
			_return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
			_preload_content=_params.get("_preload_content", True),
			_request_timeout=_params.get("_request_timeout"),
			collection_formats=_collection_formats,
			_request_auth=_params.get("_request_auth"),
		)

	@validate_arguments
	async def open_v1_project_project_id_task_task_id_complete_post(
		self,
		project_id: Annotated[StrictStr, Field(..., description="Project identifier")],
		task_id: Annotated[StrictStr, Field(..., description="Task identifier")],
		open_v1_project_project_id_task_task_id_complete_post_request: OpenV1ProjectProjectIdTaskTaskIdCompletePostRequest,
		**kwargs,
	) -> None:  # noqa: E501
		"""Update Task  # noqa: E501


		:param project_id: Project identifier (required)
		:type project_id: str
		:param task_id: Task identifier (required)
		:type task_id: str
		:param open_v1_project_project_id_task_task_id_complete_post_request: (required)
		:type open_v1_project_project_id_task_task_id_complete_post_request: OpenV1ProjectProjectIdTaskTaskIdCompletePostRequest
		:param _request_timeout: timeout setting for this request.
		       If one number provided, it will be total request
		       timeout. It can also be a pair (tuple) of
		       (connection, read) timeouts.
		:return: Returns the result object.
		         If the method is called asynchronously,
		         returns the request thread.
		:rtype: None
		"""
		kwargs["_return_http_data_only"] = True
		if "_preload_content" in kwargs:
			message = "Error! Please call the open_v1_project_project_id_task_task_id_complete_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
			raise ValueError(message)
		return await self.open_v1_project_project_id_task_task_id_complete_post_with_http_info(
			project_id, task_id, open_v1_project_project_id_task_task_id_complete_post_request, **kwargs
		)  # noqa: E501

	@validate_arguments
	async def open_v1_project_project_id_task_task_id_complete_post_with_http_info(
		self,
		project_id: Annotated[StrictStr, Field(..., description="Project identifier")],
		task_id: Annotated[StrictStr, Field(..., description="Task identifier")],
		open_v1_project_project_id_task_task_id_complete_post_request: OpenV1ProjectProjectIdTaskTaskIdCompletePostRequest,
		**kwargs,
	) -> ApiResponse:  # noqa: E501
		"""Update Task  # noqa: E501


		:param project_id: Project identifier (required)
		:type project_id: str
		:param task_id: Task identifier (required)
		:type task_id: str
		:param open_v1_project_project_id_task_task_id_complete_post_request: (required)
		:type open_v1_project_project_id_task_task_id_complete_post_request: OpenV1ProjectProjectIdTaskTaskIdCompletePostRequest
		:param _preload_content: if False, the ApiResponse.data will
		                         be set to none and raw_data will store the
		                         HTTP response body without reading/decoding.
		                         Default is True.
		:type _preload_content: bool, optional
		:param _return_http_data_only: response data instead of ApiResponse
		                               object with status code, headers, etc
		:type _return_http_data_only: bool, optional
		:param _request_timeout: timeout setting for this request. If one
		                         number provided, it will be total request
		                         timeout. It can also be a pair (tuple) of
		                         (connection, read) timeouts.
		:param _request_auth: set to override the auth_settings for an a single
		                      request; this effectively ignores the authentication
		                      in the spec for a single request.
		:type _request_auth: dict, optional
		:type _content_type: string, optional: force content-type for the request
		:return: Returns the result object.
		         If the method is called asynchronously,
		         returns the request thread.
		:rtype: None
		"""

		_params = locals()

		_all_params = ["project_id", "task_id", "open_v1_project_project_id_task_task_id_complete_post_request"]
		_all_params.extend(
			[
				"_return_http_data_only",
				"_preload_content",
				"_request_timeout",
				"_request_auth",
				"_content_type",
				"_headers",
			]
		)

		# validate the arguments
		for _key, _val in _params["kwargs"].items():
			if _key not in _all_params:
				raise ApiTypeError(
					"Got an unexpected keyword argument '%s'"
					" to method open_v1_project_project_id_task_task_id_complete_post" % _key
				)
			_params[_key] = _val
		del _params["kwargs"]

		_collection_formats = {}

		# process the path parameters
		_path_params = {}
		if _params["project_id"] is not None:
			_path_params["projectId"] = _params["project_id"]

		if _params["task_id"] is not None:
			_path_params["taskId"] = _params["task_id"]

		# process the query parameters
		_query_params = []
		# process the header parameters
		_header_params = dict(_params.get("_headers", {}))
		# process the form parameters
		_form_params = []
		_files = {}
		# process the body parameter
		_body_params = None
		if _params["open_v1_project_project_id_task_task_id_complete_post_request"] is not None:
			_body_params = _params["open_v1_project_project_id_task_task_id_complete_post_request"]

		# set the HTTP header `Content-Type`
		_content_types_list = _params.get(
			"_content_type", self.api_client.select_header_content_type(["application/json"])
		)
		if _content_types_list:
			_header_params["Content-Type"] = _content_types_list

		# authentication setting
		_auth_settings = ["OAuth2", "BearerAuth"]  # noqa: E501

		_response_types_map = {}

		return await self.api_client.call_api(
			"/open/v1/project/{projectId}/task/{taskId}/complete",
			"POST",
			_path_params,
			_query_params,
			_header_params,
			body=_body_params,
			post_params=_form_params,
			files=_files,
			response_types_map=_response_types_map,
			auth_settings=_auth_settings,
			_return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
			_preload_content=_params.get("_preload_content", True),
			_request_timeout=_params.get("_request_timeout"),
			collection_formats=_collection_formats,
			_request_auth=_params.get("_request_auth"),
		)

	@validate_arguments
	async def open_v1_project_project_id_task_task_id_delete(
		self,
		project_id: Annotated[StrictStr, Field(..., description="Project identifier")],
		task_id: Annotated[StrictStr, Field(..., description="Task identifier")],
		**kwargs,
	) -> None:  # noqa: E501
		"""Delete task.  # noqa: E501


		:param project_id: Project identifier (required)
		:type project_id: str
		:param task_id: Task identifier (required)
		:type task_id: str
		:param _request_timeout: timeout setting for this request.
		       If one number provided, it will be total request
		       timeout. It can also be a pair (tuple) of
		       (connection, read) timeouts.
		:return: Returns the result object.
		         If the method is called asynchronously,
		         returns the request thread.
		:rtype: None
		"""
		kwargs["_return_http_data_only"] = True
		if "_preload_content" in kwargs:
			message = "Error! Please call the open_v1_project_project_id_task_task_id_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
			raise ValueError(message)
		return await self.open_v1_project_project_id_task_task_id_delete_with_http_info(project_id, task_id, **kwargs)  # noqa: E501

	@validate_arguments
	async def open_v1_project_project_id_task_task_id_delete_with_http_info(
		self,
		project_id: Annotated[StrictStr, Field(..., description="Project identifier")],
		task_id: Annotated[StrictStr, Field(..., description="Task identifier")],
		**kwargs,
	) -> ApiResponse:  # noqa: E501
		"""Delete task.  # noqa: E501


		:param project_id: Project identifier (required)
		:type project_id: str
		:param task_id: Task identifier (required)
		:type task_id: str
		:param _preload_content: if False, the ApiResponse.data will
		                         be set to none and raw_data will store the
		                         HTTP response body without reading/decoding.
		                         Default is True.
		:type _preload_content: bool, optional
		:param _return_http_data_only: response data instead of ApiResponse
		                               object with status code, headers, etc
		:type _return_http_data_only: bool, optional
		:param _request_timeout: timeout setting for this request. If one
		                         number provided, it will be total request
		                         timeout. It can also be a pair (tuple) of
		                         (connection, read) timeouts.
		:param _request_auth: set to override the auth_settings for an a single
		                      request; this effectively ignores the authentication
		                      in the spec for a single request.
		:type _request_auth: dict, optional
		:type _content_type: string, optional: force content-type for the request
		:return: Returns the result object.
		         If the method is called asynchronously,
		         returns the request thread.
		:rtype: None
		"""

		_params = locals()

		_all_params = ["project_id", "task_id"]
		_all_params.extend(
			[
				"_return_http_data_only",
				"_preload_content",
				"_request_timeout",
				"_request_auth",
				"_content_type",
				"_headers",
			]
		)

		# validate the arguments
		for _key, _val in _params["kwargs"].items():
			if _key not in _all_params:
				raise ApiTypeError(
					"Got an unexpected keyword argument '%s'"
					" to method open_v1_project_project_id_task_task_id_delete" % _key
				)
			_params[_key] = _val
		del _params["kwargs"]

		_collection_formats = {}

		# process the path parameters
		_path_params = {}
		if _params["project_id"] is not None:
			_path_params["projectId"] = _params["project_id"]

		if _params["task_id"] is not None:
			_path_params["taskId"] = _params["task_id"]

		# process the query parameters
		_query_params = []
		# process the header parameters
		_header_params = dict(_params.get("_headers", {}))
		# process the form parameters
		_form_params = []
		_files = {}
		# process the body parameter
		_body_params = None
		# authentication setting
		_auth_settings = ["OAuth2", "BearerAuth"]  # noqa: E501

		_response_types_map = {}

		return await self.api_client.call_api(
			"/open/v1/project/{projectId}/task/{taskId}",
			"DELETE",
			_path_params,
			_query_params,
			_header_params,
			body=_body_params,
			post_params=_form_params,
			files=_files,
			response_types_map=_response_types_map,
			auth_settings=_auth_settings,
			_return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
			_preload_content=_params.get("_preload_content", True),
			_request_timeout=_params.get("_request_timeout"),
			collection_formats=_collection_formats,
			_request_auth=_params.get("_request_auth"),
		)

	@validate_arguments
	async def open_v1_project_project_id_task_task_id_get(
		self,
		project_id: Annotated[StrictStr, Field(..., description="Project identifier")],
		task_id: Annotated[StrictStr, Field(..., description="Task identifier")],
		**kwargs,
	) -> Task:  # noqa: E501
		"""Get Task By Project ID And Task ID.  # noqa: E501


		:param project_id: Project identifier (required)
		:type project_id: str
		:param task_id: Task identifier (required)
		:type task_id: str
		:param _request_timeout: timeout setting for this request.
		       If one number provided, it will be total request
		       timeout. It can also be a pair (tuple) of
		       (connection, read) timeouts.
		:return: Returns the result object.
		         If the method is called asynchronously,
		         returns the request thread.
		:rtype: Task
		"""
		kwargs["_return_http_data_only"] = True
		if "_preload_content" in kwargs:
			message = "Error! Please call the open_v1_project_project_id_task_task_id_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
			raise ValueError(message)
		return await self.open_v1_project_project_id_task_task_id_get_with_http_info(project_id, task_id, **kwargs)  # noqa: E501

	@validate_arguments
	async def open_v1_project_project_id_task_task_id_get_with_http_info(
		self,
		project_id: Annotated[StrictStr, Field(..., description="Project identifier")],
		task_id: Annotated[StrictStr, Field(..., description="Task identifier")],
		**kwargs,
	) -> ApiResponse:  # noqa: E501
		"""Get Task By Project ID And Task ID.  # noqa: E501


		:param project_id: Project identifier (required)
		:type project_id: str
		:param task_id: Task identifier (required)
		:type task_id: str
		:param _preload_content: if False, the ApiResponse.data will
		                         be set to none and raw_data will store the
		                         HTTP response body without reading/decoding.
		                         Default is True.
		:type _preload_content: bool, optional
		:param _return_http_data_only: response data instead of ApiResponse
		                               object with status code, headers, etc
		:type _return_http_data_only: bool, optional
		:param _request_timeout: timeout setting for this request. If one
		                         number provided, it will be total request
		                         timeout. It can also be a pair (tuple) of
		                         (connection, read) timeouts.
		:param _request_auth: set to override the auth_settings for an a single
		                      request; this effectively ignores the authentication
		                      in the spec for a single request.
		:type _request_auth: dict, optional
		:type _content_type: string, optional: force content-type for the request
		:return: Returns the result object.
		         If the method is called asynchronously,
		         returns the request thread.
		:rtype: tuple(Task, status_code(int), headers(HTTPHeaderDict))
		"""

		_params = locals()

		_all_params = ["project_id", "task_id"]
		_all_params.extend(
			[
				"_return_http_data_only",
				"_preload_content",
				"_request_timeout",
				"_request_auth",
				"_content_type",
				"_headers",
			]
		)

		# validate the arguments
		for _key, _val in _params["kwargs"].items():
			if _key not in _all_params:
				raise ApiTypeError(
					"Got an unexpected keyword argument '%s'"
					" to method open_v1_project_project_id_task_task_id_get" % _key
				)
			_params[_key] = _val
		del _params["kwargs"]

		_collection_formats = {}

		# process the path parameters
		_path_params = {}
		if _params["project_id"] is not None:
			_path_params["projectId"] = _params["project_id"]

		if _params["task_id"] is not None:
			_path_params["taskId"] = _params["task_id"]

		# process the query parameters
		_query_params = []
		# process the header parameters
		_header_params = dict(_params.get("_headers", {}))
		# process the form parameters
		_form_params = []
		_files = {}
		# process the body parameter
		_body_params = None
		# set the HTTP header `Accept`
		_header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501

		# authentication setting
		_auth_settings = ["OAuth2", "BearerAuth"]  # noqa: E501

		_response_types_map = {
			"200": "Task",
			"401": None,
			"403": None,
			"404": None,
		}

		return await self.api_client.call_api(
			"/open/v1/project/{projectId}/task/{taskId}",
			"GET",
			_path_params,
			_query_params,
			_header_params,
			body=_body_params,
			post_params=_form_params,
			files=_files,
			response_types_map=_response_types_map,
			auth_settings=_auth_settings,
			_return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
			_preload_content=_params.get("_preload_content", True),
			_request_timeout=_params.get("_request_timeout"),
			collection_formats=_collection_formats,
			_request_auth=_params.get("_request_auth"),
		)

	@validate_arguments
	async def open_v1_task_post(self, task: Task, **kwargs) -> Task:  # noqa: E501
		"""Create Task  # noqa: E501


		:param task: (required)
		:type task: Task
		:param _request_timeout: timeout setting for this request.
		       If one number provided, it will be total request
		       timeout. It can also be a pair (tuple) of
		       (connection, read) timeouts.
		:return: Returns the result object.
		         If the method is called asynchronously,
		         returns the request thread.
		:rtype: Task
		"""
		kwargs["_return_http_data_only"] = True
		if "_preload_content" in kwargs:
			message = "Error! Please call the open_v1_task_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
			raise ValueError(message)
		return await self.open_v1_task_post_with_http_info(task, **kwargs)  # noqa: E501

	@validate_arguments
	async def open_v1_task_post_with_http_info(self, task: Task, **kwargs) -> ApiResponse:  # noqa: E501
		"""Create Task  # noqa: E501


		:param task: (required)
		:type task: Task
		:param _preload_content: if False, the ApiResponse.data will
		                         be set to none and raw_data will store the
		                         HTTP response body without reading/decoding.
		                         Default is True.
		:type _preload_content: bool, optional
		:param _return_http_data_only: response data instead of ApiResponse
		                               object with status code, headers, etc
		:type _return_http_data_only: bool, optional
		:param _request_timeout: timeout setting for this request. If one
		                         number provided, it will be total request
		                         timeout. It can also be a pair (tuple) of
		                         (connection, read) timeouts.
		:param _request_auth: set to override the auth_settings for an a single
		                      request; this effectively ignores the authentication
		                      in the spec for a single request.
		:type _request_auth: dict, optional
		:type _content_type: string, optional: force content-type for the request
		:return: Returns the result object.
		         If the method is called asynchronously,
		         returns the request thread.
		:rtype: tuple(Task, status_code(int), headers(HTTPHeaderDict))
		"""

		_params = locals()

		_all_params = ["task"]
		_all_params.extend(
			[
				"_return_http_data_only",
				"_preload_content",
				"_request_timeout",
				"_request_auth",
				"_content_type",
				"_headers",
			]
		)

		# validate the arguments
		for _key, _val in _params["kwargs"].items():
			if _key not in _all_params:
				raise ApiTypeError("Got an unexpected keyword argument '%s' to method open_v1_task_post" % _key)
			_params[_key] = _val
		del _params["kwargs"]

		_collection_formats = {}

		# process the path parameters
		_path_params = {}

		# process the query parameters
		_query_params = []
		# process the header parameters
		_header_params = dict(_params.get("_headers", {}))
		# process the form parameters
		_form_params = []
		_files = {}
		# process the body parameter
		_body_params = None
		if _params["task"] is not None:
			_body_params = _params["task"]

		# set the HTTP header `Accept`
		_header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501

		# set the HTTP header `Content-Type`
		_content_types_list = _params.get(
			"_content_type", self.api_client.select_header_content_type(["application/json"])
		)
		if _content_types_list:
			_header_params["Content-Type"] = _content_types_list

		# authentication setting
		_auth_settings = ["OAuth2", "BearerAuth"]  # noqa: E501

		_response_types_map = {
			"200": "Task",
			"201": None,
			"401": None,
			"403": None,
			"404": None,
		}

		return await self.api_client.call_api(
			"/open/v1/task",
			"POST",
			_path_params,
			_query_params,
			_header_params,
			body=_body_params,
			post_params=_form_params,
			files=_files,
			response_types_map=_response_types_map,
			auth_settings=_auth_settings,
			_return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
			_preload_content=_params.get("_preload_content", True),
			_request_timeout=_params.get("_request_timeout"),
			collection_formats=_collection_formats,
			_request_auth=_params.get("_request_auth"),
		)

	@validate_arguments
	async def open_v1_task_task_id_post(
		self,
		task_id: Annotated[StrictStr, Field(..., description="Task identifier")],
		open_v1_task_task_id_post_request: OpenV1TaskTaskIdPostRequest,
		**kwargs,
	) -> Task:  # noqa: E501
		"""Update Task  # noqa: E501


		:param task_id: Task identifier (required)
		:type task_id: str
		:param open_v1_task_task_id_post_request: (required)
		:type open_v1_task_task_id_post_request: OpenV1TaskTaskIdPostRequest
		:param _request_timeout: timeout setting for this request.
		       If one number provided, it will be total request
		       timeout. It can also be a pair (tuple) of
		       (connection, read) timeouts.
		:return: Returns the result object.
		         If the method is called asynchronously,
		         returns the request thread.
		:rtype: Task
		"""
		kwargs["_return_http_data_only"] = True
		if "_preload_content" in kwargs:
			message = "Error! Please call the open_v1_task_task_id_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
			raise ValueError(message)
		return await self.open_v1_task_task_id_post_with_http_info(task_id, open_v1_task_task_id_post_request, **kwargs)  # noqa: E501

	@validate_arguments
	async def open_v1_task_task_id_post_with_http_info(
		self,
		task_id: Annotated[StrictStr, Field(..., description="Task identifier")],
		open_v1_task_task_id_post_request: OpenV1TaskTaskIdPostRequest,
		**kwargs,
	) -> ApiResponse:  # noqa: E501
		"""Update Task  # noqa: E501


		:param task_id: Task identifier (required)
		:type task_id: str
		:param open_v1_task_task_id_post_request: (required)
		:type open_v1_task_task_id_post_request: OpenV1TaskTaskIdPostRequest
		:param _preload_content: if False, the ApiResponse.data will
		                         be set to none and raw_data will store the
		                         HTTP response body without reading/decoding.
		                         Default is True.
		:type _preload_content: bool, optional
		:param _return_http_data_only: response data instead of ApiResponse
		                               object with status code, headers, etc
		:type _return_http_data_only: bool, optional
		:param _request_timeout: timeout setting for this request. If one
		                         number provided, it will be total request
		                         timeout. It can also be a pair (tuple) of
		                         (connection, read) timeouts.
		:param _request_auth: set to override the auth_settings for an a single
		                      request; this effectively ignores the authentication
		                      in the spec for a single request.
		:type _request_auth: dict, optional
		:type _content_type: string, optional: force content-type for the request
		:return: Returns the result object.
		         If the method is called asynchronously,
		         returns the request thread.
		:rtype: tuple(Task, status_code(int), headers(HTTPHeaderDict))
		"""

		_params = locals()

		_all_params = ["task_id", "open_v1_task_task_id_post_request"]
		_all_params.extend(
			[
				"_return_http_data_only",
				"_preload_content",
				"_request_timeout",
				"_request_auth",
				"_content_type",
				"_headers",
			]
		)

		# validate the arguments
		for _key, _val in _params["kwargs"].items():
			if _key not in _all_params:
				raise ApiTypeError("Got an unexpected keyword argument '%s' to method open_v1_task_task_id_post" % _key)
			_params[_key] = _val
		del _params["kwargs"]

		_collection_formats = {}

		# process the path parameters
		_path_params = {}
		if _params["task_id"] is not None:
			_path_params["taskId"] = _params["task_id"]

		# process the query parameters
		_query_params = []
		# process the header parameters
		_header_params = dict(_params.get("_headers", {}))
		# process the form parameters
		_form_params = []
		_files = {}
		# process the body parameter
		_body_params = None
		if _params["open_v1_task_task_id_post_request"] is not None:
			_body_params = _params["open_v1_task_task_id_post_request"]

		# set the HTTP header `Accept`
		_header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501

		# set the HTTP header `Content-Type`
		_content_types_list = _params.get(
			"_content_type", self.api_client.select_header_content_type(["application/json"])
		)
		if _content_types_list:
			_header_params["Content-Type"] = _content_types_list

		# authentication setting
		_auth_settings = ["OAuth2", "BearerAuth"]  # noqa: E501

		_response_types_map = {
			"200": "Task",
			"201": None,
			"401": None,
			"403": None,
			"404": None,
		}

		return await self.api_client.call_api(
			"/open/v1/task/{taskId}",
			"POST",
			_path_params,
			_query_params,
			_header_params,
			body=_body_params,
			post_params=_form_params,
			files=_files,
			response_types_map=_response_types_map,
			auth_settings=_auth_settings,
			_return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
			_preload_content=_params.get("_preload_content", True),
			_request_timeout=_params.get("_request_timeout"),
			collection_formats=_collection_formats,
			_request_auth=_params.get("_request_auth"),
		)
